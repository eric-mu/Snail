Chunk ::= Block
Block ::= (Statement)+
Statement ::= Import | Assignment | Condition | Forloop | Whileloop | Functiondef | Classdef | Processkeys

Import ::= import Name (as Name)?
Assignments ::= Assignment (',' Assignment)*
Assignment ::= (Vars '=')? Expressions
Condition ::= if Expression '{' Block? '}' (elseif Expression '{' Block? '}')* (else '{' Block? '}')?
Foroop ::= for Names in Expressions '{' Block? '}'
Whileloop ::= while Expression '{' Block? '}'
Processkeys ::= continue | break | yield | pass

Expressions ::= Expression (',' Expression)*
Expression ::= Var | Functioncall | Classgen | '(' Expression ')' | Literaltypes
Vars ::= Var (',' Var)*
Var ::= Name | Expression | Expression '[' (Expression | Slice) ']' | Expression '.' Name
Slice ::= Expression? ':' Expression? ':' Expression?
Names ::= Name (',' Name)*
Literaltypes ::= nil | Bool | String | Bytes | Number | Tuple | List | Dict

Functioncall ::= Var Args
Functiondef ::= func (name '::')? Name '(' Params? ')' '{' Block? '}'
Args ::= '(' Expressions? ')'
Params ::= Names (',' '*' Name)? (',' '**' Name)?
Name ::= (_A-Za-z)(_0-9A-Za-z)*

Classgen ::= Var Args
Classdef ::= class Name '{' (Name ('=' Expression)?)* '}'

Bool ::= true | false
String ::= 's'? '"' [^"]* '"' | 's'? "'" [^']* "'"
Bytes ::= 'b' '"' [^"]* '"' | 'b' "'" [^']* "'"
Number ::= ('0' | '0x' | '0X')? [0-9]+ ('.' [0-9]*)?
Tuple ::= Expression ',' | '(' Expression ',' ')' | Expression (',' Expression)+ | '(' Expression (',' Expression)+ ')'
List ::= '[' Expressions? ']'
Dict ::= '{' Expression ':' Expression (',' Expression ':' Expression)* '}'

Whitespace ::= Space | Comment
Space ::= #x9 | #xA | #xD | #x20
Comment ::= '/*' ( [^*] | '*'+ [^*/] )* '*'* '*/'